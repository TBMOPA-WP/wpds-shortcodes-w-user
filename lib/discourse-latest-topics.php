<?php

namespace WPDiscourse\LatestTopics;

use WPDiscourse\Utilities\Utilities as DiscourseUtilities;

class LatestTopics {

	/**
	 * The key for the plugin's options array.
	 *
	 * @access protected
	 * @var string
	 */
	protected $option_key = 'dclt_options';

	/**
	 * The merged options from WP Discourse and WP Discourse Latest Topics.
	 *
	 * All options are held in a single array, use a custom plugin prefix to avoid naming collisions with wp-discourse.
	 *
	 * @access protected
	 * @var array
	 */
	protected $options;

	/**
	 * The Discourse forum url.
	 *
	 * @access protected
	 * @var string
	 */
	protected $discourse_url;

	/**
	 * The options array added by this plugin.
	 *
	 * @access protected
	 * @var array
	 */
	protected $dclt_options = array(
		'dclt_cache_duration'     => 10,
		'dclt_webhook_refresh'    => 0,
		'dclt_webhook_secret'     => '',
		'dclt_clear_topics_cache' => 0,
		'dclt_use_default_styles' => 1,
		'dclt_new_webhook_request' => 0,
	);

	/**
	 * LatestTopics constructor.
	 */
	public function __construct() {
		add_action( 'init', array( $this, 'initialize_plugin' ) );
		add_filter( 'wpdc_utilities_options_array', array( $this, 'add_options' ) );
		add_action( 'rest_api_init', array( $this, 'initialize_topic_route' ) );
		add_action( 'wp_enqueue_scripts', array( $this, 'plugin_scripts' ) );
	}

	/**
	 * Adds the plugin options, gets the merged wp-discourse/wp-discourse-latest-topics options, sets the discourse_url.
	 */
	public function initialize_plugin() {
		add_option( 'dclt_options', $this->dclt_options );
		$this->options       = DiscourseUtilities::get_options();
		$this->discourse_url = ! empty( $this->options['url'] ) ? $this->options['url'] : null;
	}

	/**
	 * Enqueue styles.
	 */
	public function plugin_scripts() {
		if ( ! empty( $this->options['dclt_use_default_styles'] ) && 1 === intval( $this->options['dclt_use_default_styles'] ) ) {
			wp_register_style( 'dclt_styles', plugins_url( '/css/styles.css', __FILE__ ) );
			wp_enqueue_style( 'dclt_styles' );
		}
	}

	/**
	 * Hooks into 'wpdc_utilities_options_array'.
	 *
	 * This function merges the plugins options with the options array that is created in
	 * WPDiscourse\Utilities\Utilities::get_options. Doing this makes it possible to use the FormHelper function in the plugin.
	 * If you aren't using the FormHelper function, there is no need to do this.
	 *
	 * @param array $wpdc_options The unfiltered Discourse options.
	 *
	 * @return array
	 */
	public function add_options( $wpdc_options ) {
		static $merged_options = [];

		if ( empty( $merged_options ) ) {
			$added_options = get_option( $this->option_key );
			if ( is_array( $added_options ) ) {
				$merged_options = array_merge( $wpdc_options, $added_options );
			} else {
				$merged_options = $wpdc_options;
			}
		}

		return $merged_options;
	}

	/**
	 * Initializes a WordPress Rest API route and endpoint.
	 */
	public function initialize_topic_route() {
		register_rest_route( 'wp-discourse/v1', 'latest-topics', array(
			'methods'  => 'POST',
			'callback' => array( $this, 'process_latest_topics_request' ),
		) );
	}

	/**
	 * Callback function for handling the REST API request.
	 * WP_REST_Request objects are generated by WordPress when an HTTP request is made to a registered REST API route.
	 * They are used to store and retrieve information for the current request.
	 * Reference: https://developer.wordpress.org/reference/classes/wp_rest_request/
	 *
	 * @param \WP_REST_Request $data
	 *
	 * @return null
	 */
	public function process_latest_topics_request( $data ) {
		$data = $this->verify_discourse_request( $data );

		if ( is_wp_error( $data ) ) {
			error_log( $data->get_error_message() );

			return null;
		}

		/**
		 * Success! All that is happening here is that the option 'dclt_new_webhook_request' is being set. This
		 * is then used to force the plugin to request fresh topics in 'get_latest_topics'.
		 */
		$plugin_options = get_option( $this->option_key );
		$plugin_options['dclt_new_webhook_request'] = 1;

		update_option( $this->option_key, $plugin_options );
	}


	/**
	 * Get the latest topics from either from the stored transient, or from Discourse.
	 *
	 * @param int|string $cache_duration The cache duration for the topics.
	 * @param bool $force Whether to force retrieving new topics from Discourse.
	 *
	 * @return array|mixed|null|object
	 */
	public function get_latest_topics() {
		$discourse_topics = get_transient( 'dclt_latest_topics' );
		$plugin_options = get_option( $this->option_key);
		$force = ! empty( $plugin_options['dclt_clear_topics_cache']) ? $plugin_options['dclt_clear_topics_cache'] : 0;
		$new_topics = ! empty( $plugin_options['dclt_new_webhook_request']) ? $plugin_options['dclt_new_webhook_request'] : 0;

		if ( empty( $discourse_topics ) || $force || $new_topics ) {


			$discourse_topics = $this->latest_topics();
			$cache_duration   = ! empty( $plugin_options['dclt_cache_duration'] ) ? $plugin_options['dclt_cache_duration'] : 10;
			set_transient( 'dclt_latest_topics', $discourse_topics, $cache_duration * MINUTE_IN_SECONDS );

			if ( $force || $new_topics ) {
				$plugin_options['dclt_clear_topics_cache'] = 0;
				$plugin_options['dclt_new_webhook_request'] = 0;

				update_option( $this->option_key, $plugin_options );
			}
		}

		return $discourse_topics;
	}

	/**
	 * Gets the latest topics from Discourse.
	 *
	 * @return array|mixed|null|object
	 */
	protected function latest_topics() {
		if ( empty( $this->discourse_url ) ) {

			return null;
		}

		$latest_url = esc_url( $this->discourse_url . '/latest.json' );

		$remote = wp_remote_get( $latest_url );

		if ( ! DiscourseUtilities::validate( $remote ) ) {

			return null;
		}

		return json_decode( wp_remote_retrieve_body( $remote ), true );
	}

	/**
	 * Verify that the request originated from a Discourse webhook and the the secret keys match.
	 *
	 * @param \WP_REST_Request $data
	 *
	 * @return \WP_Error|\WP_REST_Request
	 */
	protected function verify_discourse_request( $data ) {
		// The X-Discourse-Event-Signature consists of 'sha256=' . hamc of raw payload.
		// It is generated by computing `hash_hmac( 'sha256', $payload, $secret )`
		if ( $sig = substr( $data->get_header( 'X-Discourse-Event-Signature' ), 7 ) ) {
			$payload = $data->get_body();
			// Key used for verifying the request - a matching key needs to be set on the Discourse webhook.
			$secret = ! empty( $this->options['dclt_webhook_secret']) ? $this->options['dclt_webhook_secret'] : null;

			if ( ! $secret ) {
				return new \WP_Error( 'Webhook Secret Missing', 'The webhook secret key has not been set.' );
			}

			if ( $sig === hash_hmac( 'sha256', $payload, $secret ) ) {

				return $data;
			} else {

				return new \WP_Error( 'Authentication Failed', 'Discourse Webhook Request Error: signatures did not match.' );
			}
		} else {
			return new \WP_Error( 'Access Denied', 'Discourse Webhook Request Error: the X-Discourse-Event-Signature was not set for the request.' );
		}
	}
}
