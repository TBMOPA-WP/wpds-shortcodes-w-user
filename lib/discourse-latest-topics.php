<?php

namespace WPDiscourse\Shortcodes;

use WPDiscourse\Utilities\Utilities as DiscourseUtilities;

class LatestTopics {

	/**
	 * The key for the plugin's options array.
	 *
	 * @access protected
	 * @var string
	 */
	protected $option_key = 'dclt_options';

	/**
	 * The merged options from WP Discourse and WP Discourse Latest Topics.
	 *
	 * All options are held in a single array, use a custom plugin prefix to avoid naming collisions with wp-discourse.
	 *
	 * @access protected
	 * @var array
	 */
	protected $options;

	/**
	 * The Discourse forum url.
	 *
	 * @access protected
	 * @var string
	 */
	protected $discourse_url;

	/**
	 * The options array added by this plugin.
	 *
	 * @access protected
	 * @var array
	 */
	protected $dclt_options = array(
		'dclt_cache_duration'     => 10,
		'dclt_webhook_refresh'    => 0,
		'dclt_webhook_secret'     => '',
		'dclt_clear_topics_cache' => 0,
		'dclt_use_default_styles' => 1,
	);

	/**
	 * LatestTopics constructor.
	 */
	public function __construct() {
		add_action( 'init', array( $this, 'initialize_plugin' ) );
		add_action( 'rest_api_init', array( $this, 'initialize_topic_route' ) );
	}

	/**
	 * Adds the plugin options, gets the merged wp-discourse/wp-discourse-latest-topics options, sets the discourse_url.
	 */
	public function initialize_plugin() {
		$this->options       = DiscourseUtilities::get_options();
		// Todo: don't do this.
		$this->discourse_url = ! empty( $this->options['url'] ) ? $this->options['url'] : null;
	}

	/**
	 * Initializes a WordPress Rest API route and endpoint.
	 */
	public function initialize_topic_route() {
		register_rest_route( 'wp-discourse/v1', 'latest-topics', array(
			array(
				'methods'  => \WP_REST_Server::CREATABLE,
				'callback' => array( $this, 'create_latest_topics' ),
			),
			array(
				'methods'  => \WP_REST_Server::READABLE,
				'callback' => array( $this, 'get_latest_topics' ),
			)
		) );
	}

	/**
	 * Create latest topics.
	 *
	 *
	 * @param \WP_REST_Request $data
	 *
	 * @return null
	 */
	public function create_latest_topics( $data ) {
		$api_enabled = ! empty( $this->options['dclt_webhook_refresh'] ) && 1 === intval( $this->options['dclt_webhook_refresh'] );
		if ( ! $api_enabled ) {

			return 0;
		}

		$data = $this->verify_discourse_request( $data );

		if ( is_wp_error( $data ) ) {
			error_log( $data->get_error_message() );

			return null;
		}

		$latest = $this->latest_topics();

		set_transient( 'dclt_latest_topics', $latest, DAY_IN_SECONDS );

		return 1;
	}

	/**
	 * Get the latest topics from either from the stored transient, or from Discourse.
	 *
	 * @return array
	 */
	public function get_latest_topics() {
		$discourse_topics = get_transient( 'dclt_latest_topics' );
		$plugin_options   = get_option( $this->option_key );
		$force            = ! empty( $plugin_options['dclt_clear_topics_cache'] ) ? $plugin_options['dclt_clear_topics_cache'] : 0;

		if ( empty( $discourse_topics ) || $force ) {

			$discourse_topics = $this->latest_topics();
			$cache_duration   = ! empty( $plugin_options['dclt_cache_duration'] ) ? $plugin_options['dclt_cache_duration'] : 10;

			// Todo: This could be set to null. Something needs to happen here.
			set_transient( 'dclt_latest_topics', $discourse_topics, $cache_duration * MINUTE_IN_SECONDS );

			if ( $force ) {
				$plugin_options['dclt_clear_topics_cache'] = 0;

				update_option( $this->option_key, $plugin_options );
			}
		}

		return $discourse_topics;
	}

	/**
	 * Gets the latest topics from Discourse.
	 *
	 * @return array|mixed|null|object
	 */
	protected function latest_topics() {
		if ( empty( $this->discourse_url ) ) {

			return null;
		}

		$latest_url = esc_url( $this->discourse_url . '/latest.json' );

		$remote = wp_remote_get( $latest_url );

		if ( ! DiscourseUtilities::validate( $remote ) ) {

			return null;
		}

		return json_decode( wp_remote_retrieve_body( $remote ), true );
	}

	/**
	 * Verify that the request originated from a Discourse webhook and the the secret keys match.
	 *
	 * @param \WP_REST_Request $data
	 *
	 * @return \WP_Error|\WP_REST_Request
	 */
	protected function verify_discourse_request( $data ) {
		// The X-Discourse-Event-Signature consists of 'sha256=' . hamc of raw payload.
		// It is generated by computing `hash_hmac( 'sha256', $payload, $secret )`
		if ( $sig = substr( $data->get_header( 'X-Discourse-Event-Signature' ), 7 ) ) {
			$payload = $data->get_body();
			// Key used for verifying the request - a matching key needs to be set on the Discourse webhook.
			$secret = ! empty( $this->options['dclt_webhook_secret'] ) ? $this->options['dclt_webhook_secret'] : null;

			if ( ! $secret ) {
				return new \WP_Error( 'Webhook Secret Missing', 'The webhook secret key has not been set.' );
			}

			if ( $sig === hash_hmac( 'sha256', $payload, $secret ) ) {

				return $data;
			} else {

				return new \WP_Error( 'Authentication Failed', 'Discourse Webhook Request Error: signatures did not match.' );
			}
		} else {
			return new \WP_Error( 'Access Denied', 'Discourse Webhook Request Error: the X-Discourse-Event-Signature was not set for the request.' );
		}
	}
}
